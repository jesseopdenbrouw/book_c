\chapter{Variabelen, datatypes en expressies}
\label{cha:vardatexp}
\thispagestyle{empty}

Een C-programma bestaat uit variabelen en functies. We gebruiken variabelen om data te bewerken, zoals berekenen van nieuwe waarden of testen of twee variabelen aan elkaar gelijk zijn. De compiler moet weten welke variabelen in een programma gebruikt worden en hoe groot de variabelen zijn. De meeste moderne computersystemen kunnen werken met 64-bits eenheden en dat betekent dat een variabele een bepaald bereik heeft; niet elk getal kunnen we in een variabele opslaan.
We gebruiken functies om bewerkingen op de variabelen te beschrijven. We hebben al twee functies gezien: \texttt{main} en \texttt{square\_root}. Functies worden in detail behandeld in hoofdstuk~\ref{cha:functies}.


\section{Variabelen}
%Een \textsl{variabele}\index{variabele} is een object waaraan een waarde kan worden toegekend. Technisch gezien is een variabele een plek in het geheugen van een computer. Een variabele moet in het C-programma kenbaar gemaakt worden. We noemen dat de \textsl{definitie}\index{definitie} van de variabele. Bij de definitie wordt het \textsl{type} van de variabele opgegeven. Zo geeft de definitie
Een \textsl{variabele}\index{variabele} is technisch gezien een plek in het geheugen van een computer waaraan een waarde kan worden toegekend. Een variabele moet in het C-programma kenbaar gemaakt worden. We noemen dat de \textsl{definitie}\index{definitie} van de variabele. Bij de definitie wordt het \textsl{type} van de variabele opgegeven. Zo geeft de definitie

\hspace*{1em}\texttt{int a;}

aan dat in het programma de variabele \texttt{a} wordt gebruikt van het type \texttt{int}. Een \texttt{int} is een geheel getal; het Engelse woord hiervoor is \textsl{integer}\index{integer}. Getallen met een komma, zoals~$3,14159$, kunnen we niet in een \texttt{int} opslaan. We kunnen nu in het programma de waarde van de variabele vastleggen met een \textsl{toekenning}\index{toekenning}. In het Engels is dat een \textsl{assignment}\index{assignmemt}. Als we aan \texttt{a} de waarde 2 willen toekennen dan schrijven we

\hspace*{1em}\texttt{a = 2;}

De C-compiler zorgt ervoor dat in het geheugen van de computer ruimte wordt gereserveerd om de variabele op te slaan. Als we in een programma de variabele \texttt{a} gebruiken dan weet de compiler op welk geheugenadres hij moet zoeken. We mogen de variabele een onbeperkt aantal keer aanpassen, zie listing~\ref{cod:assignment}.

\begin{figure}[!ht]
\begin{lstlisting}[caption=Meerdere toekenningen aan een variabele.,label=cod:assignment]
int a;
...
a = 2;
...
a = -3;
...
a = 5;
\end{lstlisting}
\end{figure}

De naam van een variabele mag 31 karakters lang zijn. Er is geen noodzaak (en zelfs \textsl{bad practice}) om namen uit één karakters te laten bestaan. Hoofdletters en kleine letters zijn \textsl{niet} gelijk aan elkaar dus \texttt{count} is niet hetzelfde als \texttt{COUNT}. Dit wordt \textsl{case sensitive}\index{case sensitive} genoemd. Overigens accepteren de meeste  C-compilers langere namen dan 31 karakters.

Er zijn enkele regels aan de namen van variabelen:

\begin{itemize}
\item Moet beginnen met een letter;
\item Mag alleen letters, cijfers en de underscore\index{underscore} bevatten;
\item Mag geen keyword zijn;
\item Mag geen bekende functienaam zijn;\footnote{Dat mag wel, maar dan kunnen we de functie niet in een programma gebruiken. We kunnen dus schrijven \texttt{int printf;} maar dan kan de \texttt{printf}-functie niet aangeroepen worden.}
\item Mag niet eerder gedefinieerd zijn;
\end{itemize}

\begin{infobox}[Inhouden en bevatten]
Als we spreken over ``de variabele'' dan bedoelen we van de inhoud, waarde of adres van de variabele. We schrijven de assignment als

\hspace*{1em}\texttt{a = 2;}

en zeggen dan ``de variabele \texttt{a} is 2 geworden''. We bedoelen dan dat de inhoud van de variabele 2 is geworden. De term waarde is meestal een synoniem van inhoud. We spreken ook wel van toekennen, dus aan de variabele wordt een waarde toegekend.
\end{infobox}

Enkele goede voorbeelden:

\hspace*{1em}\texttt{Count}\quad\texttt{val23}\quad\texttt{loop\_counter}\quad\texttt{ary2to4}

Enkele foute voorbeelden:

\hspace*{1em}\texttt{\_loop}\quad\texttt{50cent}\quad\texttt{int}\quad\texttt{static}

De meeste C-compilers accepteren de underscore als eerste karakter. Dit wordt echter afgeraden omdat veel \textsl{systeemroutines} de underscore als eerste karakter gebruiken en dat kan problemen geven in de latere stadia van de compilatie (zie hoofdstuk~\ref{cha:compilatieproces}).

Bij de definitie van variabelen mogen ook gelijk waarden worden toegekend, op voorspraak dat de waarden bekend zijn of ter plaatse berekend kunnen worden. Een voorbeeld is hieronder te zien:\index{initialisatie}

\hspace*{1em}\texttt{int a = 2;}\\
\hspace*{1em}\texttt{int b = a + 3 + 5;}


\section{Datatypes}
Een variabele is van een bepaald \textsl{datatype}\index{datatype}. We hebben er al twee gezien, de \texttt{int} en de \texttt{double}. Een datatype heeft een bepaalde grootte. Zo bestaat een \texttt{int} \textsl{meestal} uit 32 bits. Er zijn echter ook systemen en C-compilers waar een \texttt{int} uit 16 bits bestaat. Dat een \texttt{int} uit 32 bits bestaat, betekent dat niet elk willekeurig getal aan de \texttt{int} kunnen worden toegekend. Er is een minimale en maximale waarde. Voor de \texttt{int} is de minimale waarde $-2147483648$ en de maximale waarde $+2147483647$. De \texttt{int} is een \textsl{signed} datatype: zowel positieve als negatieve getallen en 0 zijn mogelijk.

Nu is de grootte van een \texttt{int} niet altijd noodzakelijk of toereikend in een bepaalde situatie. We kunnen dan kiezen voor een ander type. C kent een aantal gehele datatypes van diverse grootten. Deze zijn weergegeven in tabel~\ref{tab:varintdatatypes}. Gehele getallen worden opgeslagen in de two'scomplement representatie maar voor de gebruiker is dan niet van belang. Zie~\cite{opdenbrouw2020}.

\begin{table}[!ht]
\centering
\caption{De signed dataypes die beschikbaar zijn in C.}
\label{tab:varintdatatypes}
\begin{tabular}{@{}lcc@{}}
\toprule
\textbf{type}                         & \textbf{bits} & \textbf{bereik}  \\ \midrule
\texttt{char}                         & 8                       & $-128$ --- $+127$  \\
\texttt{short int}                    & 16                      & $-32768$ --- $+32767$ \\
\multirow{2}{*}{\texttt{int}}         & 16                      & $-32768$ --- $+32767$ \\
                                      & 32                      & $-2147483648$ --- $+2147483647$ \\
\multirow{2}{*}{\texttt{long int}}    & 32                      & $-2147483648$ --- $+2147483647$ \\
                                      & 64                      & $-9223372036854775808$ --- $+9223372036854775807$  \\
%\texttt{long int}                     & 32                      & $-2147483648$ --- $+2147483647$  \\
\texttt{long long int}                & 64                      & $-9223372036854775808$ --- $+9223372036854775807$  \\
   \bottomrule
\end{tabular}
\end{table}

\indexkeyword{int}\indexkeyword{char}\indexkeyword{short}\indexkeyword{long}\indexkeyword{long long}
Een \texttt{char}\footnote{We gaan hier er stilzwijgend vanuit dat een \texttt{char} een signed datatype is. Dat is echter niet zo. Een \texttt{char} kan ook unsigned zijn. Dit is afhankelijk van de gebruikte compiler \textsl{en} instellingen van de compiler. Het is echter wel mogelijk om tijdens compilatie de \textsl{signedness} in te stellen.} wordt gebruikt om een karakter op te slaan en is 8 bits groot. De interpretatie van het opgeslagen karakter is afhankelijk van de computer waarop het programma draait. Merk op dat een \texttt{char} zowel negatieve als positieve waarden kan bevatten. De meest gebruikte codering is de ASCII-code (zie bijlage~\ref{cha:asciitabel}). Om het karakter `A' op te slaan schrijven we:

\hspace*{1em}\texttt{char karak;}\\
\hspace*{1em}\texttt{karak = \textquotesingle A\textquotesingle; \ \ \ /* assign character A */}

Nu is de C-compiler erg coulant in het toekennen van waarden. We mogen voor de toekenning ook een getal gebruiken. We kunnen het bovenstaande ook schrijven als:

\hspace*{1em}\texttt{char karak;}\\
\hspace*{1em}\texttt{karak = 65; \ \ \ /* assign character A */}

Uiteraard moet de waarde passen en we merken terloops op dat negatieve waarden geen echte karakters voorstellen. Een \texttt{short int} is meestal 16 bits. Een \texttt{int} is 16 of 32 bits groot afhankelijk van de gebruikte C-compiler en de onderliggende hardware. Een \texttt{long int} is 32 bits of 64 bits. De C-standaard legt vast dat:

\hspace*{1em}grootte \texttt{short int} $\quad\leq\quad$ grootte \texttt{int} $\quad\leq\quad$ grootte \texttt{long int}

De keywords \texttt{short} en \texttt{long} worden \textsl{qualifiers}\index{qualifier} genoemd. Bij gebruik hiervan mag \texttt{int} weggelaten worden:

\hspace*{1em}\texttt{short sh; \ \ \ /* short int */}\\
\hspace*{1em}\texttt{long lo; \ \ \ \ /* long int */}

Als we aan een integer alleen maar positieve waarden of 0 toekennen dan kunnen we de qualifier \texttt{unsigned}\index{unsigned} bij definitie opgeven. Het (positieve) bereik is dan ongeveer twee keer zo groot als bij de signed variant:

\hspace*{1em}\texttt{unsigned char uch; \ \ \ \ \ \ \ \ \ \ \ /* range 0 to 255, a.k.a byte */}\\
\hspace*{1em}\texttt{unsigned short int usi; \ \ \ \ \ \ /* range 0 to 65535 */}\\
\hspace*{1em}\texttt{unsigned long long int ulli; \ /* range 0 to 18446744073709551616 */}

Naast gehele datatypes kent C ook een drietal \textsl{floating point} datatypes\index{floating point}. Het Nederlandse woord hiervoor is \textsl{drijvende komma}. Hier ontstaat al gelijk de eerste verwarring: in C wordt de komma vervangen door de punt, zoals gebruikelijk is in Engelstalige literatuur. We schijven dus 3.14 en niet 3,14.

Een \texttt{float}\indexkeyword{float} is een datatype met een grootte van 32 bits. Een \texttt{double}\indexkeyword{double} is een datatype met een grootte van 64 bits. We zouden verwachten dat de \texttt{long double}\indexkeyword{long double} dan een datatype van 128 bits is, maar dat is niet altijd waar. De \texttt{long double} is soms ook 80 bits, bijvoorbeeld in Intel-processoren.

\begin{table}[!ht]
\centering
\caption{De floating point dataypes die beschikbaar zijn in C.}
\label{tab:varfloatdatatypes}
\begin{tabular}{@{}lccc@{}}
\toprule
\textbf{type}          & \textbf{bits} & \textbf{kleinste positieve getal} &  \textbf{grootste positieve getal} \\ \midrule
\texttt{float}         & 32                      & $\approx1,18\times10^{-38}$ & $\approx3,4\times10^{38}$  \\
\texttt{double   }     & 64                      & $\approx2.2\times10^{-308}$ & $\approx1.8\times10^{308}$ \\
\texttt{long double}   & 80/128                      & $^1$) & $^1$)  \\
\bottomrule
\end{tabular}\\\vspace*{1mm}
\footnotesize$^1$) Afhankelijk van de implementatie is een long double 80 of 128 bits.
\end{table}

Voorbeelden van floating point variabelen:

\hspace*{1em}\texttt{float f;}\\
\hspace*{1em}\texttt{double d;}

Met betrekking tot de nauwkeurigheid kunnen we nog het volgende vermelden. Een \texttt{float} heeft een nauwkeurigheid van ongeveer 6 decimale cijfers. Het heeft dus geen zin om meer cijfers toe te voegen, de extra cijfers worden genegeerd. Een \texttt{double} heeft een nauwkeurigheid van ongeveer 16 decimale cijfers. Niet alle getallen kunnen exact in een floating point-variabele worden opgeslagen. Zo is 1/7 niet exact te representeren. Bij veelvuldig rekenen met floating point-variabelen treedt er verlies op in de representatie. Als we bijvoorbeeld 1/3 met 3 vermenigvuldigen, kan het zijn dat het resultaat 0,99999 is en niet 1,0. De floating-point weergave maakt het mogelijk om een breed dynamisch bereik van waarden te bestrijken met een constant aantal significante cijfers.

Al deze datatypes worden \textsl{enkelvoudige datatypes}\index{enkelvoudige datatypes} genoemd. Dat betekent dat de compiler ze ziet als één eenheid. Het is niet mogelijk om enkelvoudige datatypes te splitsen over meerdere andere datatypes.

Naast de genoemde datatypes bestaan er nog twee andere datatypes: \texttt{bool}\index{bool} (vanaf C99) kan de waarde \texttt{true} of \texttt{false} bevatten en \texttt{complex}\index{complex} (vanaf C99) kan een complex getal bevatten.

Een veel gebruikt datatype is de \textsl{pointer}\index{pointer}. Een pointer is een variabele die het \textsl{adres}\index{adres} bevat van een (andere) variabele. Pointers worden in detail behandeld in hoofdstuk~\ref{cha:pointers}.


\section{Constanten}
\index{constante}
Een gehele constante zoals \texttt{123} is van het type \texttt{int}. Door er een \texttt{L} of \texttt{l} achter te zetten wordt de constante een \texttt{long}. Dus \texttt{123L} is een \texttt{long}. Als een constante te groot is voor een \texttt{int} wordt het automatisch gezien als een \texttt{long}. Een unsigned constante wordt aangegeven met een \texttt{U} of \texttt{u} aan het einde. Dat mag in combinatie met de \texttt{L}. Om een constante als long long aan te duiden wordt de constante gevolgd door \texttt{LL} of \texttt{ll} eventueel vooraf gegaan door een \texttt{U} of \texttt{u} om de constante als unsigned te typeren.


Een floating point-constante bestaat uit cijfers en een punt. Dus \texttt{1.23} is een floating point-constante. Om 10-machten aan te geven wordt de $E$-notatie gebruikt. Zo staat \texttt{125.0E-3} voor $0,125$. Een floating point-constante is automatisch van het type \texttt{double}, tenzij er een \texttt{F} of \texttt{f} aan het einde staat, dan is de constante van het type \texttt{float}.

Gehele constanten kunnen als getal op drie manieren worden ingevoerd: als decimaal getal, als octaal getal of als hexadecimaal getal. Een constante die begint met \texttt{0} wordt gezien als octaal getal. Een octaal getal bestaat alleen uit de cijfers 0 t/m 7. Een constante die begin met de \textsl{prefix}\index{prefix} \texttt{0x} of \texttt{0X} wordt gezien als een hexadecimaal getal. Een constante die begint met de cijfers \texttt{1} t/m \texttt{9} wordt gezien als een decimaal getal.

\hspace*{1em}\texttt{int a = 0377; \ \ \ /* octal 377 is decimal 255 */}\\ 
\hspace*{1em}\texttt{int b = 0xa9; \ \ \ /* hexadecimal A9 is decimal 169 */}\\ 
\hspace*{1em}\texttt{int c = 127; \ \ \ \ /* decimal 127 */}

De C-standaard kent geen manier om binaire getallen in te voeren. Veel compilers ondersteunen dit toch door de prefix \texttt{0b} of \texttt{0B} te gebruiken. Zo is de constante \texttt{0b10101001} gelijk aan~169 (decimaal).

Een\textsl{ karakterconstante}\index{karakterconstante} is een geheel getal, geschreven als een één karakter tussen apostrofes. Zo is \texttt{\textquotesingle A\textquotesingle} een karakterconstante. De interne representatie is een geheel getal dat overeen komt met de karakterset van de computer. Over het algemeen wordt de ASCII-code gebruikt en komt \texttt{\textquotesingle A\textquotesingle} overeen met de waarde 65.
De standaard ASCII-tabel is te vinden in bijlage~\ref{cha:asciitabel}.

Niet alle karakters kunnen zo worden ingevoerd. Een voorbeeld is het karakter \texttt{\textquotesingle} zelf. Om dit karakter in te voeren gebruiken we een \textsl{escape sequence}\index{escape sequence}. Een escape sequence bestaat uit een \textsl{backslash}\index{backslash karakter} (\texttt{\textbackslash}) en een karakter. We kunnen de apostrofe dus invoeren als \texttt{\textquotesingle\textbackslash\textquotesingle\textquotesingle}.

De C-standaard kent een hele verzameling van dit soort escape sequences. Eén daarvan hebben we al meerdere malen gezien: de newline. Deze wordt aangegeven met \texttt{\textquotesingle\textbackslash n\textquotesingle}. Een aantal escape sequences is vermeld in tabel~\ref{tab:varescseq}.

\begin{table}[!ht]
\centering
\caption{Enkele escape sequences in C.}
\label{tab:varescseq}
\begin{tabular}{llp{1cm}ll}
\toprule
\texttt{\textbackslash n} & \texttt{n}ewline         &  & \texttt{\textbackslash\textbackslash}  & backslash \\
\texttt{\textbackslash r} & carriage \texttt{r}eturn &  & \texttt{\textbackslash\textquotesingle} & single quote \\
\texttt{\textbackslash a} & \texttt{a}udible bell    &  & \texttt{\textbackslash "} & double quote \\
\texttt{\textbackslash b} & \texttt{b}ackspace       &  & \texttt{\textbackslash 0} & null byte \\
\texttt{\textbackslash f} & \texttt{f}ormfeed        &  & \texttt{\textbackslash t} & horizontal \texttt{t}ab \\
\bottomrule
\end{tabular}
\end{table}

\indextwo{\textbackslash n}{newline karakter}\index{newline}
\indextwo{\textbackslash r}{carriage return karakter}\index{carriage return}
\indextwo{\textbackslash \textbackslash }{backslash karakter}\index{backslash}
\indextwo{\textbackslash 0}{nul-karakter}
\indextwo{\textbackslash t}{horizontal tab karakter}\index{horizontal tab}

Andere karakters kunnen worden gevormd door de backslash, gevolgd door de letter \texttt{x} en één of twee hexadecimale cijfers. We kunnen de letter \texttt{A} dus ook schrijven als \texttt{\textquotesingle\textbackslash x41\textquotesingle}.

Een \textsl{string constante}\index{string constante}, of kortweg string\index{string}, is een rij van karakters die wordt begonnen en afgesloten met aanhalingstekens. De rij mag ook leeg zijn. Dan spreken we dan van een lege string. Twee voorbeelden:

\begin{lstlisting}[style=lstoneline]
"Dit is een string"  /* String with characters */
""                   /* The empty string */
\end{lstlisting}

Let erop dat een string \textsl{geen} enkelvoudig datatype is zoals \texttt{int} en \texttt{double}. Een string is een rij karakters die in het geheugen liggen. Technisch gezien is een string een \textsl{array}\index{string array}. We kunnen dus niet de waarde van een string bepalen zoals dat wel mogelijk is van een \texttt{int} of een \texttt{char}. Aan het einde van een string wordt automatisch een nul-karakter\index{nul-karakter} geplaatst. Er is dus altijd één karakter meer nodig dan het aantal karakters in een string. In figuur~\ref{fig:varstrings} zijn de twee strings afgebeeld. De \texttt{\textquotesingle\textbackslash0\textquotesingle} stelt het nul-karakter voor.

\begin{figure}[!ht]
\centering
\begin{tikzpicture}[pointerstyle]
\foreach \ii [count=\i from 0] in {D, i, t, \ , i, s, \ ,e, e, n, \ , s, t, r, i, n, g, \textbackslash 0} {
	\node[memlocarray] (nod\i) at (\i*\unitsize,0) {\strut\ii};
	\draw (nod\i) node[yshift=\unitsize cm] {\footnotesize\i}; 
}
\foreach \ii [count=\i from 0] in {\textbackslash 0} {
	\node[memlocarray] (nod\i) at (\i*\unitsize+7,-2) {\strut\ii};
	\draw (nod\i) node[yshift=\unitsize cm] {\footnotesize\i}; 
}
\end{tikzpicture}
\caption{Uitbeelding van twee strings.}
\label{fig:varstrings}
\end{figure}

C kent geen ingebouwde operaties op strings, zoals inkorten, aan elkaar plakken, kopiëren of lengte bepalen. Dit moet allemaal door de programmeur zelf ontworpen worden. Gelukkig kent de standard library een groot aantal functies voor het bewerken van strings. We komen hierop terug in hoofdstuk~\ref{cha:arrays}.

Bij de definitie van variabelen mogen ook gelijk waarden worden toegekend, op voorspraak dat de toegekende waarde op dat moment kan worden berekend. Dat betekent dat gebruikte variabelen bekend moeten zijn. Een aantal voorbeelden is hieronder te zien:

\hspace*{1em}\texttt{int a = 2;}\\
\hspace*{1em}\texttt{char z = \textquotesingle z\textquotesingle;}\\
\hspace*{1em}\texttt{short b = -10+5+a;}\\
\hspace*{1em}\texttt{long l = 123L;}\\
\hspace*{1em}\texttt{float tau = 2.0F*3.14159F;}\\
\hspace*{1em}\texttt{double e = 2.718281828;}\\
\hspace*{1em}\texttt{double googol = 1E100;}\\
\hspace*{1em}\texttt{unsigned char maxbyte = 128+127;}

Let erop dat de constante wordt geconverteerd naar het type van de variabele. Sommige compilers geven een waarschuwing als zo'n conversie plaatsvindt.

\hspace*{1em}\texttt{int a = 25.6; \ \ /* converted to 25 */}\\
\hspace*{1em}\texttt{float b = 7; \ \ \ /* converted to 7.0 */}

Bij de definitie van een variabele mag de qualifier \texttt{const}\indexkeyword{const} worden opgegeven dat inhoudt dat aan  de variabele eenmalig een waarde wordt toegekend. De \texttt{const}-variabele kan daarna niet meer veranderen. Dat is bijzonder handig als we een constante waarde moeten gebruiken in een programma. Zo kunnen we na de definitie

\hspace*{1em}\texttt{const int aantal = 10;}

de variabele \texttt{aantal} gebruiken als vervanging voor het getal 10. Als later blijkt dat het aantal moet worden aangepast, dan hoeven we alleen maar de variabele \texttt{aantal} aan te passen.

Uiteraard moet de constante passen. Als we bijvoorbeeld

\hspace*{1em}\texttt{char ch = 65536;}

uitvoeren zal de compiler een waarschuwing geven dat de constante niet past in een \texttt{char}.


\section{Expressies}
\index{expressie}
Een \textsl{expressie} is elk stukje programma dat een uitkomst oplevert. Zo is \texttt{2+2} een expressie die de waarde 4 oplevert. We kunnen de uitkomst van een expressie toekennen aan een variabele. De toekenning zelf is ook een expressie:

\hspace*{1em}\texttt{a = 2 + 2;}

Een expressie mag variabelen bevatten:

\hspace*{1em}\texttt{a = b - c;}

Zelfs de regel

\hspace*{1em}\texttt{a;}

is een expressie die 4 oplevert als de waarde van \texttt{a} 4 is, alhoewel er met deze waarde niets wordt gedaan. Ook het vergelijken van twee variabelen is een expressie en mag toegekend worden aan een variabele:

\hspace*{1em}\texttt{a = b == c; \ \ \  /* note the == */}

Als \texttt{b} gelijk is aan \texttt{c} dan wordt \texttt{a} gelijk aan 1. Als \texttt{b} ongelijk is aan \texttt{c} dan wordt \texttt{a} gelijk aan~0. We zullen het vergelijken van variabelen en constanten nader bekijken in hoofdstuk~\ref{cha:programmabesturing}.

Een expressie mag willekeurig complex zijn, maar let op de voorrangsregels: vermenigvuldigen en delen gaan voor op optellen en aftrekken. Haakjes worden gebruikt om de prioriteiten te veranderen:

\hspace*{1em}\texttt{a = (2+b)*5+c;}

\subsection{Rekenkundige operatoren}
C kent vijf \textsl{binaire} rekenkundige operatoren: \texttt{*}\indextwo{*}{vermenigvuldigen} voor vermenigvuldigen, \texttt{/}\indextwo{/}{delen} voor delen, \texttt{\%}\indextwo{\%}{modulus operator} voor de modulus, \texttt{+}\indextwo{+}{optellen} voor optellen en \texttt{-}\indextwo{$-$}{aftrekken} voor aftrekken. Binair wil in dit verband zeggen dat de operatoren op twee variabelen (of constanten of expressies) werken. 
%De \textsl{binaire} rekenkundige operatoren zijn \texttt{*}\indextwo{*}{vermenigvuldigen}, \texttt{/}\indextwo{/}{delen}, \texttt{\% }\indextwo{\%}{modulus operator}, \texttt{+}\indextwo{+}{optellen} en \texttt{-}\indextwo{$-$}{aftrekken}. Binair wil in dit verband zeggen dat de operatoren op twee variabelen (of constanten of expressies) werken.
De expressie

\hspace*{1em}\texttt{a \% b}

berekent de rest van de deling van \texttt{a} gedeeld door \texttt{b}. Dit wordt de \textsl{modulus operator}\index{modulus operator} genoemd. Deze operator mag alleen op gehele getallen gebruikt worden. Daarnaast kunnen \texttt{+} en \texttt{-} ook als \textsl{unaire operator}\index{unaire operator} gebruikt worden. Een voorbeeld hiervan is

\hspace*{1em}\texttt{int a = -(b+c);}

Let goed op de prioriteiten van de operatoren. De unaire operatoren gaan voor op vermenigvuldigen (\texttt{*}), delen (\texttt{/}) en modulus (\texttt{\%}). De binaire optelling (\texttt{+}) en aftrekking (\texttt{-}) hebben en lagere prioriteit dan \texttt{*}, \texttt{/} en \texttt{\%}. Haakjes kunnen de volgorde veranderen. Merk op dat de \textsl{associativiteit}\index{associativiteit} van deze operatoren van links naar rechts is. Dus de expressie

\hspace*{1em}\texttt{a / b / c}

is equivalent aan

\hspace*{1em}\texttt{(a / b) / c}
 
maar \textsl{niet} aan

\hspace*{1em}\texttt{a / (b / c)}

Verder moet worden opgelet bij deling van gehele getallen. Een deling rondt naar beneden af, dus de \textsl{fractie}\index{fractie}, het deel van een getal na de komma, wordt weggelaten. Dat betekent dat

\hspace*{1em}\texttt{1 / 3 * 3}

de waarde 0 oplevert. Eerst wordt 1/3 berekend en de gehele uitkomst hiervan is 0. Daarna wordt de uitkomst met 3 vermenigvuldigd. De uitkomst is nog steeds 0.

Let overigens goed op bij het delen met negatieve getallen. Het quotiënt wordt afgerond naar~0 toe. Het programma in listing~\ref{cod:vardivproblem} verduidelijkt dat.
%
\begin{figure}[!ht]
\begin{lstlisting}[caption=Delen van positieve en negatieve getallen.,label=cod:vardivproblem]
#include <stdio.h>

int main(void) {

	printf(" 7/ 3 = %2d\n",  7/ 3);
	printf(" 7/-3 = %2d\n",  7/-3);
	printf("-7/ 3 = %2d\n", -7/ 3);
	printf("-7/-3 = %2d\n", -7/-3);
	return 0;
}
\end{lstlisting}
\end{figure}
%
De uitvoer van het programma is te zien in figuur~\ref{fig:vardivproblem}.
%
\begin{dosbox}[title=Uitvoer van het deelprogramma.,label=fig:vardivproblem]
 7/ 3 =  2
 7/-3 = -2
-7/ 3 = -2
-7/-3 =  2
\end{dosbox}
%
Als het resultaat van de deling een positief getal oplevert, wordt het resultaat naar beneden (naar de 0 toe) afgerond. Is het resultaat negatief, dan wordt het resultaat naar boven afgerond (ook naar de 0 toe).

\subsection{Relationele operatoren}
De zes \textsl{relationele operatoren}\index{relationele operatoren} zijn

\hspace*{1em}\texttt{==} \quad \texttt{!=} \quad \texttt{>} \quad \texttt{>=} \quad \texttt{<} \quad \texttt{<=}

\indexop{==}\indexop{"!=}\indexop{>}\indexop{>=}\indexop{<}\indexop{<=}
Hierin zijn \texttt{==} gelijk aan (let op de dubbele \texttt{=}) en \texttt{!=} ongelijk aan. Verder is \texttt{>} groter dan, \texttt{>=} is groter dan of gelijk aan, \texttt{<} is kleiner dan en \texttt{<=} is kleiner dan of gelijk aan. Deze hebben een lagere prioriteit dan de alle rekenkundige en unaire operatoren, dus \mbox{\texttt{i < len-1}} wordt gelezen als \texttt{i < (len-1)}. Overigens hebben \texttt{==} en \texttt{!=} een lagere prioriteit dan de overige vier. Een relationele operator levert de waarde 1 op als de vergelijking waar is en anders levert de relationele operator~0 op.
De relationele operatoren hebben vooral nut bij beslissingen. Zie listing~\ref{cod:varexampleif0}.

\begin{figure}[!ht]
\begin{lstlisting}[caption=Voorbeeld van een beslissing.,label=cod:varexampleif0]
int main(void)
{
    int a, b;
    
    printf("Geef getal a: ");
    scanf("%d", &a);
    printf("Geef getal b: ");
    scanf("%d", &b);

    if (a < b)
    {
        printf("a is kleiner dan b\n");
    }
    else if (a == b)
    {
        printf("a is gelijk aan b\n");
    }
    else
    {
        printf("a is groter dan b\n");
    }
    return 0;
}
\end{lstlisting}
\end{figure}

\subsection{Logische operatoren}
\index{logische operatoren}
De \texttt{\&\&}-\indextwo{\&\&}{logische AND} en \texttt{||}-operatoren\indextwo{\textbar{}\textbar{}}{logische OR} zijn logische operatoren die expressies met elkaar verbinden. Ze hebben een relatie met de relationele operatoren. Zo wordt variabele \texttt{isdig} in de expressie

\hspace*{1em}\texttt{isdig = ch>=\textquotesingle0\textquotesingle\ \&\& ch<=\textquotesingle9\textquotesingle;}

gelijk aan 1 als \texttt{ch} een cijferkarakter is, anders wordt \texttt{isdig} 0. In de expressie

\hspace*{1em}\texttt{isbit = ch==\textquotesingle0\textquotesingle\ || ch==\textquotesingle1\textquotesingle;}

wordt \texttt{isbit} gelijk aan 1 als \texttt{ch} een `0' of een `1' is, anders wordt \texttt{isbit} gelijk aan 0. Het berekenen van een dergelijke expressie wordt gestopt op het moment dat de uitkomst al duidelijk is. Dus de berekening van

\hspace*{1em}\texttt{i==5 \&\& j>3}

wordt gestopt als \texttt{i} ongelijk aan 5 is. De uitkomst staat dan namelijk al vast. Dit wordt \textsl{shortcut evaluation}\index{shortcut evaluation} genoemd.

De unaire \textsl{negatieoperator}\index{negatieoperator} \texttt{!}\indextwo{"!}{logische negatie} zet een expressie die 0 oplevert om in een 1 en een expressie die \textsl{niet-nul}\index{niet-nul} oplevert wordt omgezet in een 0. Een typisch gebruik van \texttt{!} is te zien in listing~\ref{cod:varnegop}.

\begin{figure}[!ht]
\begin{lstlisting}[caption=Voorbeeld van de negatieoperator.,label=cod:varnegop]
int main(void)
{
    int a, valid;
    
    printf("Geef een getal tussen 5 en 10: ");
    scanf("%d", &a);
    
    valid = a<5 || a>10;

    if (!valid)   /* if valid is 0 */
    {
        /* do something ... */
    }

    return 0;
}
\end{lstlisting}
\end{figure}

Overigens kan in dit voorbeeld het gebruik van de variabele \texttt{valid} vermeden worden door gebruik te maken van

\begin{lstlisting}[style=lstoneline]
if (!(a<5 || a>10)) { ... }
\end{lstlisting}

Met al deze operatoren kunnen we willekeurig complexe expressies realiseren. Om bijvoorbeeld te bepalen of een jaartal een schrikkeljaar\index{schrikkeljaar} (Engels: leap year)\index{leap year} is, gebruiken we de volgende expressie:

\hspace*{1em}\texttt{int leap = (year \% 4 == 0 \&\& year \% 100 != 0) || year \% 400 == 0};
%%\begin{lstlisting}[style=lstoneline]
%%int leap = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0};
%%\end{lstlisting}

We zullen het even uitleggen. Een schrikkeljaar is een jaar met als extra dag 29 februari. Zo'n jaartal is deelbaar door 4 en niet deelbaar door 100, of als het jaartal deelbaar is door~400, dan is het wel een schrikkeljaar. Dus 1984 is een schrikkeljaar, 2100 is geen schrikkeljaar maar~2000 weer wel. Deze expressie wordt vaak gebruikt bij het bepalen van een geldige datum.

\subsection{Bitsgewijze operatoren}
\index{AND}\index{OR}\index{EXOR}
C biedt zes zogenoemde \textsl{bitsgewijze operatoren}\index{bitsgewijze operatoren}. Ze kunnen alleen maar gebruikt worden bij gehele variabelen, constanten of expressies. Deze zijn:

\begin{tabular}{p{1cm}l}
 \texttt{\&}       & AND \\  
 \texttt{\textbar} & OR \\
 \texttt{\^{}}     & EXOR \\
 \texttt{<<}       & naar links schuiven \\
 \texttt{>>}       & naar rechts schuiven \\
 \texttt{\textasciitilde} & bits inverteren
\end{tabular}

\indextwo{\&}{bitsgewijze AND}\indextwo{\textbar}{bitsgewijze OR}\indextwo{\^{}}{bitsgewijze EXOR}\indextwo{<<}{links schuiven}\indextwo{>>}{rechts schuiven}\indextwo{\textasciitilde}{bitsgewijze inverse}

Opmerking: De bitsgewijze operatoren werken op bits van gehele getallen. Dit is iets anders dan de relationele operatoren. Hierbij worden relaties tussen twee expressies gevormd en daar kan waar (1) of onwaar (0) uit volgen.

De \textsl{waarheidstabellen}\index{waarheidstabel} van de AND-, OR- en EXOR-functies zijn gegeven in tabel~\ref{tab:driebaisfuncties}. De AND-functie wordt gebruikt om een of meer bits uit een variabele te selecteren of op 0 te zetten. De OR-functie wordt gebruikt om bits in een variabele op 1 te zetten en de EXOR-functie wordt gebruikt om bits in een variabele te inverteren (een 0 wordt een 1 en een 1 wordt een 0).


\begin{table}[!ht]
\centering
\caption{De drie bitsgewijze operatoren.}
\label{tab:driebaisfuncties}
\begin{subtable}[t]{0.333\textwidth}
\centering
\caption{AND-functie.}
\label{tab:enbasisfunctie}
\begin{tabular}{cc|c}
0 & 0 & 0  \\
0 & 1 & 0  \\
1 & 0 & 0  \\
1 & 1 & 1  \\
\end{tabular}
\end{subtable}%
\begin{subtable}[t]{0.333\textwidth}
\centering
\caption{OR-functie.}
\label{tab:ofbasisfunctie}
\begin{tabular}{cc|c}
0 & 0 & 0  \\
0 & 1 & 1  \\
1 & 0 & 1  \\
1 & 1 & 1  \\
\end{tabular}
\end{subtable}%
\begin{subtable}[t]{0.333\textwidth}
\centering
\caption{EXOR-functie.}
\label{tab:exofbasisfunctie}
\begin{tabular}{cc|c}
0 & 0 & 0  \\
0 & 1 & 1  \\
1 & 0 & 1  \\
1 & 1 & 0  \\
\end{tabular}
\end{subtable}
\end{table}

De schuifoperator\index{schuifoperator} \texttt{<<} schuift de bits in een variabele een aantal plekken naar links. De vrijgekomen bits worden opgevuld met nullen. De bits die aan de linkerkant ``eruit vallen'' gaan verloren. De expressie

\hspace*{1em}\texttt{ 1 << 4}

geeft als resultaat 16. De schuifoperator \texttt{>>} schuift de bits in een variabele een aantal plekken naar rechts. De vrijgekomen bits worden \textsl{bij unsigned variabelen} aangevuld met nullen. Bij  \textsl{signed variabelen} worden ze aangevuld met de \textsl{tekenbit}\index{tekenbit}. De bits die aan de rechterkant eruit vallen gaan verloren. De unaire operator \texttt{\textasciitilde} inverteert\index{inverteren} alle bits in een variabele. Een bit die 1 is wordt een 0 en een bit die 0 is wordt een 1. Dit wordt ook wel \textsl{one's complement}\index{one's complement} genoemd.

De operatoren kunnen door elkaar gebruikt worden. Een voorbeeld is:

\hspace*{1em}\texttt{a = a \& \textasciitilde 0xff;}

Deze expressie zorgt ervoor dat de 8 minst significante bits allemaal 0 worden en de overige bits ongemoeid laat. In figuur~\ref{fig:threeexamples} zijn drie voorbeelden te zien van bitmanupilaties met AND, OR en EXOR. Hiervoor zijn de gegevens uit tabel~\ref{tab:driebaisfuncties} gebruikt.

\begin{figure}[!ht]
\centering
\begin{tabular}{rl}
\footnotesize 7 \hspace*{3.0cm} 0 & \\
\fbox{1}\fbox{0}\fbox{1}\fbox{0}\fbox{1}\fbox{0}\fbox{1}\fbox{0} & \\[1ex]
\fbox{1}\fbox{0}\fbox{0}\fbox{0}\fbox{0}\fbox{0}\fbox{0}\fbox{0} & AND\\[0.5ex]
\cmidrule{1-1}
\fbox{1}\fbox{0}\fbox{0}\fbox{0}\fbox{0}\fbox{0}\fbox{0}\fbox{0} & \\[3ex]

\fbox{1}\fbox{1}\fbox{0}\fbox{1}\fbox{1}\fbox{0}\fbox{1}\fbox{0} & \\[1ex]
\fbox{1}\fbox{1}\fbox{0}\fbox{0}\fbox{1}\fbox{1}\fbox{0}\fbox{0} & OR\\[0.5ex]
\cmidrule{1-1}
\fbox{1}\fbox{1}\fbox{0}\fbox{1}\fbox{1}\fbox{1}\fbox{1}\fbox{0} & \\[3ex]

\fbox{1}\fbox{1}\fbox{0}\fbox{1}\fbox{1}\fbox{0}\fbox{1}\fbox{0} & \\[1ex]
\fbox{1}\fbox{1}\fbox{1}\fbox{1}\fbox{0}\fbox{0}\fbox{0}\fbox{0} & EXOR\\[0.5ex]
\cmidrule{1-1}
\fbox{0}\fbox{0}\fbox{1}\fbox{0}\fbox{1}\fbox{0}\fbox{1}\fbox{0} & \\[3ex]
\end{tabular}
\caption{Drie voorbeelden van AND, OR en EXOR.}
\label{fig:threeexamples}
\end{figure}

Een bekend voorbeeld is het testen of een geheel getal even of oneven is. Een even geheel getal is exact deelbaar door 2. We kunnen dit realiseren met de modulo-operator\indexop{modulo} \texttt{\%}:

\hspace*{1em}\texttt{if (getal \% 2 == 0) \{ ... \}}

We kunnen dit ook realiseren het de \texttt{\&}-operator, zie het programma in listing~\ref{cod:testeven1}.
%
\begin{figure}[!ht]
\begin{lstlisting}[caption=Testen of een geheel getal even is.,label=cod:testeven1]
#include <stdio.h>

int main(void)
{
    int getal;
    
    printf("Geef een geheel getal: ");
    scanf("%d", &getal);
    
    if (getal & 1 == 0)
    {
        printf("Getal is even\n");
    } 
    else
    {
        printf("Getal is oneven\n");
    }
    
    return 0;
}
\end{lstlisting}
\end{figure}
%
De expressie \texttt{getal \& 1} in regel 10 zorgt ervoor dat alle bits op 0 gezet worden, behalve het minst significante bit. Dit bit geeft aan of het getal even (0) of oneven (1) is.

%%%De bitsgewijze operatoren zijn bijzonder handig bij het gebruik van \textsl{microcontrollers}. In een ``normaal'' C-programma komen ze eigenlijk niet voor. We geven ter illustratie een voorbeeld voor een ATmega-microcontroller\index{ATmega}. Deze processor wordt onder andere gebruikt in de Arduino Uno~\cite{arduinouno}. We willen testen of een schakelaar is ingedrukt. We lezen de stand van de schakelaars in via de (speciale) variabele \texttt{PINA}. Als de schakelaar op bit 7 (hoogste bit van \texttt{PINA}) is ingedrukt, dan inverteren we de stand van de led die is gekoppeld aan bit~0 (laagste bit) van de (speciale) variabele \texttt{PORTB}.
%%%
%%%\begin{figure}[!ht]
%%%\begin{lstlisting}[caption=Gebruik van bitsgewijze operatoren.]
%%%#include <avr/io.h>                /* PINA, PORTB, ... */
%%%
%%%int main(void)
%%%{
%%%    if ((PINA & 0x80) == 0x80)     /* if key is pressed ... */
%%%    {
%%%        PORTB = PORTB ^ 0x01;      /* ... invert lower led */
%%%    }
%%%
%%%}
%%%\end{lstlisting}
%%%\end{figure}


\section{Datatypeconversie}
Het omzetten of converteren\index{datatypeconversie} van het ene enkelvoudige datatype naar het andere enkelvoudige datatype kan op twee manieren worden gerealiseerd: automatisch door de C-compiler of expliciet door een \textsl{type cast} in het programma. We kunnen redelijkerwijs verwachten dat een ``kleiner'' type wordt omgezet naar een ``groter'' type. We noemen dat \textsl{promotie}\index{promotie}. De regels voor automatische conversie zijn complex; we geven hier slecht een korte opsomming:

\begin{itemize}
\item Als een van de twee operanden een \texttt{long double} is, converteer de andere naar \texttt{long double};
\item Als een van de twee operanden een \texttt{double} is, converteer de andere naar \texttt{double};
\item Als een van de twee operanden een \texttt{float} is, converteer de andere naar \texttt{float};
\item Converteer \texttt{char} en \texttt{short} naar \texttt{int};
\item Als een van de twee operanden een \texttt{long} is, converteer de andere naar \texttt{long}.
\end{itemize}

De regels voor unsigned variabelen zijn nog lastiger, zeker als ze gecombineerd worden met signed integers. Het beste is om deze \textsl{mixed types} te vermijden.

Een conversie kan ook expliciet worden opgegeven. We noemen dit een \textsl{type cast}\index{type cast}. We geven dit aan door het type tussen haken te zetten:

\hspace*{1em}\texttt{i = (int) ch; \ \ \  /* promote character to integer */}

In dit geval geeft dat geen problemen want een karakter past in een integer. Maar de cast:

\hspace*{1em}\texttt{ch = (char) i; \ \ \  /* demote integer to character */}

kan voor problemen zorgen als de waarde van \texttt{i} te groot is om in een karakter te plaatsen. Er gaan dan bits verloren. Een mooi voorbeeld van een type cast is het omrekenen van een temperatuur in graden Celsius naar graden Fahrenheit. 

Stel we hebben de temperatuur in graden Celsius opgeslagen in de \texttt{double} variabele \texttt{c} en de temperatuur in Fahrenheit willen berekenen (ook een \texttt{double}). Dat kan met het onderstaande statement:

\hspace*{1em}\texttt{f = (double)9/5 * c + 32;}

We hebben hier de integer 9 gecast naar een \texttt{double} want anders gaat bij de deling 9/5 informatie verloren; de \textsl{gehele} uitkomst van de deling \texttt{9/5} is immers \texttt{1}. De constante 32 hoeft niet gecast te worden omdat eerder al de getallen en variabelen naar een \texttt{double} gecast zijn. Natuurlijk hadden we ook kunnen schrijven:

\begin{lstlisting}[style=lstoneline]
f = 9.0/5.0 * c + 32.0;
\end{lstlisting}
 

\section{Overflow}
\textsl{Overflow}\index{overflow} is de situatie wanneer een expressie een waarde oplevert die te groot of te klein is en niet in de variabele kan worden opgeslagen. De C-compiler genereert geen code om hierop te testen. Dat zou wel kunnen, maar dat zou de executietijd van programma's nadelig beïnvloeden. De ontwerper van het programma moet er dus zelf op toezien dat een overflow-conditie niet kan voorkomen. De reden dat overflow voorkomt is dat datatypes (en dus variabelen) uit een eindig aantal bits\index{bit} bestaan. Zo bestaat een \texttt{unsigned char} uit 8 bits en het grootste getal dat kan worden opgeslagen is 255 (binair $11111111_2$). Tellen we daar 1 bij op dat is het resultaat 256 (binair $100000000_2$) maar dat kan niet in de variabele worden opgeslagen. Het resultaat is dat de overvloedige bits (de leidende 1  in dit geval) gewoonweg worden geschrapt en dat de uitkomst dus $00000000_2$ (0) is. Dit principe geldt ook bij de \lstc{int} en \lstc{long int}.

Overflow bij floating point-getallen werkt anders. Dat heeft te maken met de gebruikte specificatie van de getallen.
Naast representeerbare getallen kent de floating point-specificatie nog drie speciale getallen: $+\infty$ (oneindig positief), $-\infty$ (oneindig negatief) en \texttt{NaN}\index{nan} (Not A Number). Ze geeft de deling 1/0 als resultaat $+\infty$\footnote{Volgens de wiskunde is het resultaat van een deling door 0 onbepaald. De specificatie definieert echter de deling als $\pm$oneindig.}. De deling 0/0 resulteert in NaN.


\section{Vaste-lenge datatypes}
Dat de grootte van integers aan elkaar gerelateerd zijn, kan in programma's voor problemen zorgen of tot problemen leiden. We weten nu niet of een \texttt{int} 16 of 32 bits is. Dit heeft geleid tot een aantal nieuwe datatypes die in de C99-standaard zijn vastgelegd. De grootte van deze types zijn exact. Zo is een \texttt{int8\_t} een integer van precies 8 bits ($-128$ t/m $+127$). Naast de integer met teken zijn er ook types zonder teken. Zo is een \texttt{uint16\_t} een integer van precies~16 bits met een minimale waarde van 0 en een maximale waarde van 65535.

Voor ``normaal'' gebruik zijn deze datatypes niet echt nodig. Maar bij het schrijven van programma's op microcontrollers is het vaak de enige goede methode om er zeker van te zijn dat een bepaalde grootte van een variabele gegarandeerd is. Dit is met name belangrijk bij het gebruik van zogenoemde \textsl{I/O-adressen}\index{I/O-adressen}. Dat zijn speciale adressen in het geheugen van de microcontroller waarmee communicatie met de buitenwereld mogelijk is, zoals het inlezen van de stand van een schakelaar of het laten branden van een led.

In de tabellen~\ref{tab:varinttdatatypes} en~\ref{tab:varuinttdatatypes} zijn de nieuwe datatypes voor signed en unsigned te zien. Voordat we ze kunnen gebruiken moeten we eerst het\ header-bestand\indextwo{stdint.h}{header-bestand} \texttt{stdint.h} laden. Dit is te zien in listing~\ref{cod:vastelengte}.

\begin{table}[!ht]
\centering
\caption{De vaste-lengte dataypes die beschikbaar zijn in C (signed).}
\label{tab:varinttdatatypes}
\begin{tabular}{@{}lcrl@{}}
\toprule
\textbf{type}          & \textbf{bits} & \textbf{kleinste getal} &  \textbf{grootste getal} \\ \midrule
\texttt{int8\_t}       & 8             & $-128$                  & $+127$  \\
\texttt{int16\_t}      & 16            & $-32768$                & $+32767$  \\
\texttt{int32\_t}      & 32            & $-2147483648$           & $+2147483647$  \\
\texttt{int64\_t}      & 64            & $-9223372036854775808$  & $+9223372036854775807$  \\
\bottomrule
\end{tabular}\\
\end{table}

\begin{table}[!ht]
\centering
\caption{De vaste-lengte dataypes die beschikbaar zijn in C (unsigned).}
\label{tab:varuinttdatatypes}
\begin{tabular}{@{}lcr@{}}
\toprule
\textbf{type}          & \textbf{bits} & \textbf{grootste getal} \\ \midrule
\texttt{uint8\_t}       & 8             & $255$                   \\
\texttt{uint16\_t}      & 16            & $65535$                 \\
\texttt{uint32\_t}      & 32            & $4294967295$            \\
\texttt{uint64\_t}      & 64            & $18446744073709551615$   \\
\bottomrule
\end{tabular}\\
\end{table}

\begin{figure}[!ht]
\begin{lstlisting}[caption=Voorbeeld van het gebruik van vaste-lengte datatypes.,label=cod:vastelengte]
/* Load new datatypes */
#include <stdint.h>

int main(void)
{
    uint8_t byte = 0;
    
    /* ... */
    
    while (byte<128)
    {
        byte = byte + 1;
    }
}
\end{lstlisting}
\end{figure}


\section{Enumeraties}
\label{sec:enumeraties}
Er is in C een mogelijkheid om een eigen datatype te definiëren in combinatie met een lijst van constanten: een \textsl{enumeratie}\index{enumeratie}. Een enumeratie is een lijst van gehele constanten in de vorm van

\hspace*{1em}\texttt{enum vartype \{ TUNKNOWN; TINT; TFLOAT; TDOUBLE \};}

De eerste naam binnen de accolades krijgt impliciet de waarde 0, de volgende de waarde 1 enzovoorts. Maar het is ook mogelijk om expliciete waarden toe te kennen

\hspace*{1em}\texttt{enum vartype \{ TUNKNOWN; TINT=11; TFLOAT=13; TDOUBLE \};}

In deze enumeratie krijgt \texttt{TUNKNOWN} de waarde~0 (impliciet), \texttt{TINT} de waarde 11 (expliciet), \texttt{TFLOAT} de waarde 13 (expliciet) en \texttt{TDOUBLE} de waarde 14 (impliciet). Merk op dat er niet echt een nieuw datatype wordt gerealiseerd. De compiler zoekt uit in welk integer datatype de enumeratie past.


\section{Overige operatoren}
C kent veel operatoren. In deze paragraaf beschrijven we ze even kort. In de volgende hoofdstukken worden ze verder uitgelegd.

\subsection{Grootte van een variabele}
De grootte van een variabele of datatype in \textsl{bytes} kan berekend worden met de operator \mbox{\texttt{sizeof}}\indexop{sizeof}. Dit kan in principe alleen tijdens \textsl{compile-time} van het C-programma gebeuren. Tijdens het uitvoeren van het programma zijn alle grootten berekend\footnote{Er is één uitzondering. Vanaf C99 kan \texttt{sizeof} ook gebruikt worden bij arrays van variabele lengte, waarbij de lengte bij definitie variabel is, bijvoorbeeld bij \texttt{int a[b]} en \texttt{b} als parameter van een functie dient.}. Er is één restrictie in het gebruik van \texttt{sizeof}: bij het gebruik met een datatype \textsl{moeten} haakjes gebruikt worden. Zie listing~\ref{cod:varsizeof}. Deze operator heeft een hoge prioriteit. We zullen \texttt{sizeof} nader behandelen in hoofdstuk~\ref{cha:arrays}.

\begin{figure}[!ht]
\begin{lstlisting}[caption=Gebruik van \texttt{sizeof}.,label=cod:varsizeof]
int main(void)
{
	int i;

    if (sizeof i == sizeof (long))
    {
        printf("De grootte van i is gelijk aan een long\n");
    }

    return 0;
}
\end{lstlisting}
\end{figure}

\subsection{Verhogen of verlagen met 1}
Een toekenning als

\hspace*{1em}\texttt{i = i + 1;}

kan geschreven worden als

\hspace*{1em}\texttt{i++;}

of als 

\hspace*{1em}\texttt{++i;}

Dit wordt de \textsl{increment operator}\indexop{++}\index{increment operator} genoemd. Het verschil is dat bij \texttt{i++} eerst de waarde van \texttt{i} wordt gebruikt en daarna met 1 wordt opgehoogd (dit wordt \textsl{postfix}\index{postfix} genoemd), bij \texttt{++i} wordt de waarde van \texttt{i} eerst opgehoogd en daarna gebruikt (dit wordt \textsl{prefix}\index{prefix} genoemd). Stel dat \texttt{i} is gelijk is aan 5 dan zorgt

\hspace*{1em}\texttt{k = i++;}

ervoor dat \texttt{k} gelijk is aan 5 en \texttt{i} gelijk is aan 6. Bij

\hspace*{1em}\texttt{k = ++i;}

zijn \texttt{k} en \texttt{i} gelijk aan 6.

Op vergelijkbare wijze werkt de \textsl{decrement operator}\index{{decrement operator}} \texttt{--}\indexop{--}. De expressie

\hspace*{1em}\texttt{k = --i;}

verlaagt eerst variabele \texttt{i} en kent dan de waarde van \texttt{i} toe aan k. We zullen deze operatoren tegenkomen in de hoofdstuk~\ref{cha:programmabesturing} en~\ref{cha:arrays}. Deze operatoren hebben een hoge prioriteit. We komen deze operatoren vooral tegen bij herhalingsstatements.

Merk op dat de prefix- en postfix operatoren \textsl{ook} gebruikt mogen worden met floating point-getallen, maar in de regel gebruiken we een expliciete optelling: \lstc{x = x + 1.0;}.

\subsection{Toekenningsoperatoren}
Een toekenning als

\hspace*{1em}\texttt{i = i * 3;}

mag geschreven worden als

\hspace*{1em}\texttt{i *= 3;}

Let daarbij op dat de expressie aan de rechterkant van de toekenningsoperator als één eenheid wordt gezien. Dus

\hspace*{1em}\texttt{i *= y + 1;}

wordt uitgewerkt als

\hspace*{1em}\texttt{i = i * (y + 1);}

Zo'n beetje alle gangbare operatoren kunnen worden gebruikt. Een lijst is te vinden in tabel~\ref{tab:vartoekenningsoperatoren}. Deze operatoren hebben een lage prioriteit. Merk op dat bij de kolom ``Evaluatie'' de expressies \texttt{a} en \texttt{b} omringd zijn door haakjes. Dat geeft ook gelijk aan dat deze expressies eerst geëvalueerd worden voordat de operatie en toekenning plaatsvindt.

\begin{table}[!t]
\centering
\renewcommand{\arraystretch}{1.2}
\caption{Toekenningsoperatoren.}
\label{tab:vartoekenningsoperatoren}
\begin{tabular}{p{2cm}p{2cm}l}
\toprule
\textbf{Operatie} & & \textbf{Evaluatie} \\
\midrule
\texttt{a *= b} & lees als & \texttt{a = (a) * (b)}\\
\texttt{a /= b} & lees als & \texttt{a = (a) / (b)}\\
\texttt{a \%= b} & lees als & \texttt{a = (a) \% (b)}\\
\texttt{a += b} & lees als & \texttt{a = (a) + (b)}\\
\texttt{a -= b} & lees als & \texttt{a = (a) - (b)}\\
\texttt{a <<= b} & lees als & \texttt{a = (a) << (b)}\\
\texttt{a >>= b} & lees als & \texttt{a = (a) >> (b)}\\
\texttt{a \&= b} & lees als & \texttt{a = (a) \& (b)}\\
\texttt{a \textbar= b} & lees als & \texttt{a = (a) \textbar{} (b)}\\
\texttt{a \^{}= b} & lees als & \texttt{a = (a) \^{} (b)}\\
\bottomrule
\end{tabular}
\end{table}

\subsection{Conditionele expressie}
\label{sec:conditioneleexpressie}
De \textsl{conditionele expressie}\index{conditionele expressie}\indexop{?:} is een operator die aan de hand van de waarde van een variabele (of constante of expressie) een van de twee opgegeven expressies uitvoert. Als we de maximale waarde van \texttt{a} en \texttt{b} willen bepalen dan kunnen we schrijven:

\hspace*{1em}\texttt{max = (a > b) ? a : b; \ \ /* max = maximum(a, b) */}

Een typisch voorbeeld is het afdrukken van de meervoudsvorm van een woord (of niet). Stel dat we aan het einde van een programma afdrukken hoeveel documenten verwerkt zijn. Dan kunnen we met behulp van een conditionele expressie het woord \texttt{document} of \texttt{documenten} afdrukken. We doen dat zoals te zien is in de regels 11 en 12 in listing~\ref{cod:varnrdocs}.

\begin{figure}[!ht]
\begin{lstlisting}[caption=Het afdrukken van een meervoudsvorm.,label=cod:varnrdocs]
#include <stdio.h>

int main(void)
{
    int nrdocs = 0;

    /* ... */
    
    /*                 +-------------- nrdcos      */
    /*                 (*|*)         +---- "" or "en"  */
    /*                 (*v*)         (*v*)                 */
    printf("In totaal %d document%s verwerkt\n", nrdocs,
                                 (nrdocs == 1) ? "" : "en"));
    return 0;
}
\end{lstlisting}
\end{figure} 

Het eerste argument (\texttt{\%d)} is het aantal documenten dat verwerkt is (\texttt{nrdocs}). Het tweede argument is een string (\texttt{\%s}). De conditionele expressie

\begin{lstlisting}[style=lstoneline]
(nrdocs == 1) ? "" : "en";
\end{lstlisting}

geeft de (lege) string \lstinline[basicstyle=\ttfamily]|""| als \texttt{nrdocs} gelijk is aan 1 of de string \lstinline[basicstyle=\ttfamily]|"en"| als \texttt{nrdocs} ongelijk aan 1 is. De haken rond de expressie \texttt{nrdocs == 1} zijn eigenlijk niet nodig want de prioriteit van de conditionele expressie is erg laag, maar het komt de leesbaarheid wel ten goede.

\subsection{Komma-operator}
De komma-operator\indexop{,}\index{komma-operator} \texttt{,} scheidt twee expressies die als één statement worden gezien. Een voorbeeld van de komma-operator is

\hspace*{1em}\texttt{a = 3, b = 5;}

Bij deze expressie wordt \texttt{a} gelijk aan \texttt{3} en \texttt{b} gelijk aan \texttt{5}. Het resultaat van de gehele expressie is de rechter expressie (\texttt{b = 5}). De komma-operator wordt nogal eens gebruikt in het \texttt{for}-statement. We behandelen de komma-operator nogmaals in hoofdstuk~\ref{cha:programmabesturing}.

Let erop dat de komma's die argumenten in functie-aanroepen en variabelen in definities scheiden \textsl{geen} komma-operatoren zijn.

\subsection{Nog enkele operatoren}
De volgende operatoren worden verderop in het boek behandeld:

\hspace*{1cm}\texttt{[]\ \ ->\ \ .\ \ *} (\textsl{dereference}) \texttt{\ \ \&} (\textsl{address})

\section{Voorrangsregels van operatoren}
Bij het uitwerken van expressies worden voorrangsregels\index{voorrangsregels} gehanteerd. C kent een groot aantal operatoren. We hebben de \textsl{meest voorkomende} operatoren op volgorde van prioriteit opgesomd in tabel~\ref{tab:varvoorrangsregels}. Let hierbij goed op de \textsl{associativiteit} van de operatoren. Die is van links naar rechts óf van rechts naar links. Dat betekent bijvoorbeeld dat \lstc{1 / 3 * 3} wordt gelezen als \lstc{(1 / 3)} \lstc{* 3}, dus de associatie is van links naar rechts. De deling gaat dus voor op de vermenigvuldiging. Merk op dat de toekenningsoperator \texttt{=} ook in de lijst voorkomt, de associatie is van rechts naar links en dat deze operator een lage prioriteit heeft.

\begin{table}[!ht]
\centering
\renewcommand{\arraystretch}{1.2}
\caption{Voorrangsregels van de meeste operatoren.}
\label{tab:varvoorrangsregels}
\begin{tabular}{p{9cm}l}
\toprule
\textbf{Operatie} & \textbf{Associativiteit} \\
\midrule
\texttt{()} & links naar rechts \\
\texttt{! \textasciitilde\ + - ++ -- (}\textsl{type cast}\texttt{)} \texttt{sizeof} & rechts naar links \\
\texttt{* / \%} & links naar rechts \\
\texttt{+ -} & links naar rechts \\
\texttt{<< >>} & links naar rechts\\
\texttt{< <= > >=} & links naar rechts\\
\texttt{== !=} & links naar rechts\\
\texttt{\&} & links naar rechts\\
\texttt{\^{}} & links naar rechts\\
\texttt{\textbar} & links naar rechts\\
\texttt{\&\&} & links naar rechts\\
\texttt{\textbar\textbar} & links naar rechts\\
\texttt{?:} & rechts naar links \\
\texttt{= += -= *= /= \%= \&= \^{}= \textbar= <<= >>=} & rechts naar links \\
\texttt{,} & links naar rechts \\
\bottomrule
\end{tabular}
\end{table}

Een in C-programma's gebruikelijke constructie voor het inlezen van een karakter van het toetsenbord én gelijk testen of het een newline-karakter\index{newline} betreft is:

\hspace*{1em}\texttt{while ((ch = getchar()) != \textquotesingle\textbackslash n\textquotesingle) \{ ... \}}

Hier gebeuren eigenlijk drie dingen. Eerst wordt de \textsl{functie} \texttt{getchar}\indexfunc{getchar} aangeroepen om een karakter van het toetsenbord te lezen, de haakjes \texttt{()} direct achter \texttt{getchar} hebben de hoogste prioriteit. Daarna wordt dit karakter toegekend aan variabele \texttt{ch}. De haakjes zorgen voor de juiste prioriteit. De uitkomst van de toekenning is de gehele waarde van de toekenning en dat is het ingelezen karakter. Daarna wordt getest of het ingelezen karakter ongelijk is aan het newline-karakter (\lstinline|\n|).\indextwo{\textbackslash n}{newline karakter}\index{newline}


Uit deze tabel zijn de operatoren voor arrays (\texttt{[]}), pointers (\texttt{*} en \texttt{\&}) en structures (\texttt{->} en~\texttt{.}) weggelaten. Deze operatoren worden behandeld in volgende hoofdstukken.

Veel van deze operatoren volgen uit de noodzaak (of is het drang) om programma's compact te schrijven. Doorgewinterde programmeurs kunnen op deze manier vlot, zij het voor de beginnende programmeur minder goed leesbare, code produceren. Een eerste gedachte is dat zulke constructies bijdragen aan compacte uitvoerbare bestanden. Maar de huidige generatie compilers is zeer goed in het herkennen van de taal en genereren al bijna-minimale uitvoerbare bestanden. Het is beter om eerst een leesbaar programma te schrijven dat correct werkt en daarna gaan nadenken of het slimmer kan.
Donald Knuth schreef al eens~\cite{knuth1974}:

\begin{displayquote}
Premature optimization is the root of all evil.
\end{displayquote}
De lezer is gewaarschuwd.

\section{Volgorde van uit\textsl{}rekenen van expressies}
De volgorde van het uitrekenen van expressies ligt niet vast, behalve bij de operatoren \texttt{\&\&}, \texttt{||}, \texttt{?:} en \texttt{,}. Dit heeft voornamelijk consequenties bij het gebruik van argumenten in functies, zoals te zien is in de onderstaande functie-aanroep:

\begin{lstlisting}[style=lstoneline]
printf("{%d %d\n", ++n, --n);
\end{lstlisting}

De volgorde van het uitrekenen van \texttt{++n} en \texttt{--n} ligt niet vast. Dit kan verschillende resultaten opleveren bij gebruik van verschillende compilers. De oplossing is het gebruik van extra variabelen:

\begin{lstlisting}[style=lstoneline]
int i = ++n;
int j = --n;
printf("%d %d\n", i, j);
\end{lstlisting}